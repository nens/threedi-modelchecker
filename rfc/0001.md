- Start Date: 2021-02-09
- RFC PR: https://github.com/nens/threedi-modelchecker

# Summary

Add an API for reading from and writing to 3Di model schematisation (sqlite)
files.

# Basic examples

Initialisation:

```
>>> from threedi_modelchecker import ThreediDatabase
>>> schematisation = ThreediDatabase({"db_path": "/path/to/sqlite"})
```

Reading records: SQLAlchemy API
```
>>> channels = schematisation.channels
<sqlalchemy.orm.query.Query at 0x7faa20e9fcf8>
>>> channels.first()
<threedi_modelchecker.threedi_model.models.Channel at 0x7faa20c88a58>
>>> channels.all()
[...]
>>> channels.filter_by(display_name="577").first()
<threedi_modelchecker.threedi_model.models.Channel at 0x7faa20c88a58>
```

Writing/updating records: SQLAlchemy Session API + context manager
```
>>> from threedi_modelchecker import models
>>> with schematisation.get_session_context() as session:
...     session.add(models.Channel(...))
...     session.delete(schematisation.channels.first())
```

Bulk input to numpy
```
>>> channels.bulk_read(fields=["the_geom", "dist_calc_points"])
{
    "the_geom": array([pygeos.Geometry LINESTRING ..., ...]),
    "dist_calc_points": array([100., ...]),
}
```

# Motivation

3Di has accumulated several implementations for the schematisation I/O.

*Inpy*
The current Inpy (including migrations, makegrid, enrich) is implemented in
Django 1.6. There are 140 migrations in "south" which is a package that has been
deprecated for more than five years. It is unmaintainable.

See https://github.com/nens/threedi/tree/master/lib/threedi-tools/threedi_tools
and https://github.com/nens/threedi/tree/master/lib/threedi-spatialite-tools/threedi_spatialite_tools.

*Threedi-modelchecker*
SQLAlchemy implementation used to validate schematisations server-side.

We should replace the old Inpy implementation. Because we need a 'single source
of truth' it is a logical choice to take the new SQLAlchemy implementation.

# Detailed design

### Easy table access

Each ``Model`` can be accessed from the `ThreediDatabase` instance using 
`ThreediDatabase.modelname`. This starts a (readonly) session with autocommit=True.

### Writing: transaction management

SQLAlchemy strongly recommends working with an external `session` object. We
should not try to hide it from the end user as it is central to SQLAlchemy.

We can add a context manager that commits/rollbacks a transaction, like so:

```
@contextmanager
def session_scope():
    """Provide a transactional scope around a series of operations."""
    session = Session()
    try:
        yield session
        session.commit()
    except:
        session.rollback()
        raise
    finally:
        session.close()

```

### Columnar data access

GDAL bindings to sqlite provide a much faster way to transform data into
numpy ndarrays. This requires the following additional dependencies: ``fiona, pygeos, numpy``.
Bulk import can be an optional feature of the ORM (making the dependencies optional).

The function will internally make use of ``fiona`` to read data into a dictionary of 1D numpy arrays.
This already provides a significant performance improvement with respect to the record based IO.
In the future, ``fiona`` may natively support numpy export.

# Drawbacks

The columnar data access requires an additional engine to access the files.

# Alternatives

### Use Django as ORM

Django is not only an ORM, but also a full-featured webserver. Because of this,
it is a heavyweight dependency. We do not need most features.

Also, Django does not support geopackage.

### Use geopandas as ORM

Geopandas is a heavy dependency (pandas). Also, it does not provide database
migrations and schema validations.

# Adoption strategy

The new schematisation ORM will be part of the new modelbuilder. The old inpy
will be phased out. The migrations that are still part of the old inpy will be
put in a legacy worker to be able to keep accepting old formats.

For the rest there are no new places that require attention.

# How we teach this

...
