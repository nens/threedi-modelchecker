- Start Date: 2021-02-09
- RFC PR: https://github.com/nens/threedi-modelchecker

# Summary

Add an API for reading from and writing to 3Di model schematisation (sqlite)
files.

# Basic examples

Initialisation:

```
>>> from threedi_modelchecker import ThreediDatabase
>>> schematisation = ThreediDatabase({"db_path": "/path/to/sqlite"})
```

Reading records: SQLAlchemy API
```
>>> channels = schematisation.channels
<sqlalchemy.orm.query.Query at 0x7faa20e9fcf8>
>>> channels.first()
<threedi_modelchecker.threedi_model.models.Channel at 0x7faa20c88a58>
>>> channels.all()
[...]
>>> channels.filter_by(display_name="577").first()
<threedi_modelchecker.threedi_model.models.Channel at 0x7faa20c88a58>
```

Writing/updating records: SQLAlchemy Session API + context manager
```
>>> from threedi_modelchecker import models
>>> with schematisation.get_session_context() as session:
...     session.add(models.Channel(...))
...     session.delete(schematisation.channels.first())
```

Bulk input to numpy
```
>>> channels.bulk_read(fields=["the_geom", "dist_calc_points"])
{
    "the_geom": array([pygeos.Geometry LINESTRING ..., ...]),
    "dist_calc_points": array([100., ...]),
}
```

# Motivation

3Di has accumulated several implementations for the schematisation I/O.

*Old stack*
The code representation of the model schema lives in two places of
https://github.com/nens/threedi. One is a django model definition used to create
a so-called `v2_workdbs`, the second one a custom ORM that reads data from the
sqlite during the input file generation. The django models run on a very old
django version (1.6) that still used south migration files. It is unmaintainable.

See https://github.com/nens/threedi/tree/master/lib/threedi-tools/threedi_tools
and https://github.com/nens/threedi/tree/master/lib/threedi-spatialite-tools/threedi_spatialite_tools.

*Threedi-modelchecker*
SQLAlchemy implementation used to validate schematisations server-side.

We should replace the old Inpy implementation. Because we need a 'single source
of truth' it is a logical choice to take the new SQLAlchemy implementation.

Additional requirements (outside of this RFC) are: 

- Migration support: SQLAlchemy can support this through Alembic
- Partial model validation: SQLAlchemy supports model validators as well as
  events on attribute changes or object updates. These support sufficient
  possibilities for partial model validation.

# Detailed design

### Easy table access

Each ``Model`` can be accessed from the `ThreediDatabase` instance using 
`ThreediDatabase.modelname`. This starts a (readonly) session with autocommit=True.

### Writing: transaction management

SQLAlchemy strongly recommends working with an external `session` object. We
should not try to hide it from the end user as it is central to SQLAlchemy.

We can add a context manager that commits/rollbacks a transaction, like so:

```
@contextmanager
def session_scope():
    """Provide a transactional scope around a series of operations."""
    session = Session()
    try:
        yield session
        session.commit()
    except:
        session.rollback()
        raise
    finally:
        session.close()

```

### Columnar data access

GDAL bindings to sqlite provide a much faster way to transform data into
numpy ndarrays. This requires the following additional dependencies: ``fiona, pygeos, numpy``.
Bulk import can be an optional feature of the ORM (making the dependencies optional).

The function will eventually make use of ``fiona`` to read data into a dictionary of 1D numpy arrays.
This already provides a significant performance improvement with respect to the record based IO.
In the future, ``fiona`` may natively support numpy export.

As a first version, we will use the existing SQLAlchemy ORM and fill
a numpy array. This does not give us performance increase, but then we can
already develop against the columnar data access API before it actually exists.

# Drawbacks

- SQLAlchemy is a relatively unknown technique for our team; Django is much
  wider known.
- The columnar data access requires an additional engine to access the files.

# Alternatives

### Use Django as ORM

Django is not only an ORM, but also a full-featured webserver. Because of this,
it is a heavyweight dependency. We do not need most features.

Also, Django does not support geopackage.

### Use geopandas as ORM

Geopandas is a heavy dependency (pandas). Also, it does not provide database
migrations and schema validations.

# Adoption strategy

The new schematisation ORM will be part of the new modelbuilder. The old inpy
will be phased out. The migrations that are still part of the old inpy will be
put in a legacy worker to be able to keep accepting old formats.

For the rest there are no new places that require attention.

# How we teach this

A README in this repository suffices.
