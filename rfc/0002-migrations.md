- Start Date: 2021-02-15
- RFC PR: https://github.com/nens/threedi-modelchecker/39

# Summary

Add a method to migrate databases between different versions of the model
definition (schema).

# Basic examples

Initialisation:

```
>>> from threedi_modelchecker import ThreediDatabase
>>> db = ThreediDatabase({"db_path": "/path/to/sqlite"})
```

A database knows what version it has (including South legacy migrations):

```
>>> db.get_schema_version()
174
```

Allows inplace upgrading schematisation to the latest version provided that
the current version is larger than the latest South legacy migration:

```
>>> db.upgrade(revision_id="head")
```

Supports a method for the developer to autogenerate migrations based on a new
schematisation and a database that is up-to-date with the latest migration:

```
alembic revision --autogenerate -m "Added account table"
```

Autogenerated migrations will always need to be validated by hand.

# Motivation

There already is a method to migrate between different versions of the model
definition at https://github.com/nens/threedi/tree/master/lib/threedi-tools/threedi_tools .
We cannot keep working with this implementation; it is written using Django 1.6
and south, which didn't receive updates since 2014.

To make this code mainainable and to run it in current Python environments, we
need a new design.

# Detailed design

We will use Alembic to keep track of schema revisions and to run migrations.
Although Alembic main use is from the command line and with 1 statically
configured database, it is very flexible and also supports our use case.

### Migrating

It is not necessary to use the commandline to start migrations.
The relevant commands ``upgrade()`` and ``current()`` are 
all part of the public Alembic API and can be accessed from Python.

See: https://alembic.sqlalchemy.org/en/latest/api/commands.html

Each migration should be run in a transaction to avoid situations with a half-
executed transactions. Adding and dropping tables deserves extra attention here
because in SQLite, these cannot be done from within a transaction.


### Project structure

Revisions are stored in a so-called "Migration Environment" which has a 
folder structure like this::

```
yourproject/
    alembic/
        env.py
        script.py.mako
        versions/
            0200_initial.py
            0201_remove_v1.py
            0202_manholes.py
```

The revision versions are unordered by default. We can however control the
revision number manually. We will force a linear history by using an
increasing number, starting with ``0200`` to avoid confusion with the legacy
South migrations.

The ``env.py`` implements methods to connect to the database and to execute
migrations. This is possibly not necessary (to be investigated) because we will
manage connections ourselves through the existing ``ThreediDatabase`` class.
This also goes for the ``alembic.ini`` file (containing things like database
address). We should define this from the code.

The ``script.py.mako`` is a template for new revisions. See next section.

The reserved revision identifier ``"head"`` corresponds to the schema currently
checked in to this repository. The latest migration in ``alembic/versions`` must
always match the state of the schema in ``threedi_modelchecker/threedi_model``.

### Creating a revision

This creates an empty file based on the ``script.py.mako``::

```
alembic revision -m "create account table"
```

This creates a candidate revision file based on a change in the schema
definition and a database that is in the latest revision state::

```
alembic revision -m --autogenerate "create account table"
```

The file contains an ``upgrade`` and ``downgrade`` functions. These should be
written/validated by hand by the developer making use of Alembic operations. See
https://alembic.sqlalchemy.org/en/latest/autogenerate.html and 
https://alembic.sqlalchemy.org/en/latest/ops.html#ops.


### The initial revision

The migrations should be able to create a new database from scratch. This means
that the initial migration will contain the complete schema of the database.

This migration should 'work' for legacy databases (being on the latest
migration id) as well as for empty database files. This means faking the initial
migration for legacy databases.

See also:

https://stackoverflow.com/questions/52121596/creating-zero-state-migration-for-existing-db-with-sqlalchemy-alembic-and-fak

# Drawbacks

The drawback of using Alembic is that migrations are written in a language
that is yet unknown to our developers.

Using automatic migrations means that we can never do backwards incompatible
changes like adding new mandatory fields without providing a default.

# Alternatives

There is no alternative if we want to keep using SQLAlchemy for our schema.
The only other migration framework in Python is Django, which we do not want
to use (see RFC 0001)

# Adoption strategy

The current 172 migrations should be put in a specialized docker container, so
that they can be used for older databases. This repository starts with only an
initial migration to be able to construct an SQLite from scratch.

We are not going to add any more Django/South migrations.

The second migration in this repo will remove the v1 tables.

# How we teach this

A README in this project will suffice.
